---
title: "phylosmith"
author: "Schuyler D. smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{phylosmith}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r load_data, echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(fig.width=16, fig.height=8)
library(phyloseq)
library(phylosmith)
data(soil_column)
```

## `phylosmith` 

`phylosmith` is a conglomeration of functions written to process and analyze `phyloseq-class` objects. <a href="https://joey711.github.io/phyloseq/" targe="_blank" >Phyloseq</a> objects are a great data-standard for microbiome, gene-expression, and many other data types.

A lot of these functions are just to make "data-wrangling" easier for the user. Others will implement complex routines in a, hopefully, efficient and concise manner. I have also made functions to make figures for quick examination of data, but they may or may not be suitable for publication as some may require parameter optimization.

# Installation
```r
library(devtools)
install_github('schuyler-smith/phylosmith')
library(phylosmith)
```
\*for WINDOWS you need to install <a href="https://cran.r-project.org/bin/windows/Rtools/" target="_blank" >Rtools</a>, when prompted, select `add rtools to system PATH`.

# Functions
## Data Parsing
Call			 | Use
---------------- | ------------------------------------------------
merge_treatments | combines multiple columns in meta-data into a single column
find_common_taxa | find taxa common to each treatment
find_unique_taxa | find taxa unique to each treatment
merge_asvs       | combine ASVs to lowest common biological sequence
merge_samples | combines samples based on common factor within sample_data
order_phyloseq_metadata | sets the orders of the factors in a sample_data column (for ordering graphs)
relative_abundance | transform abundance data to relative abundance
taxa_filter | filter taxa by proportion of samples seen in

## Graphs
Call			 | Use
---------------- | ------------------------------------------------
abundance_heatmap_ggplot | create a ggplot object of the heatmaps of the abndance table
abundance_lines_ggplot | create a ggplot object of the abundance data as a line graph
network_phyloseq | creates a network of the co-occurrence of taxa
nmds_phyloseq_ggplot  | create a ggplot object of the NMDS from a phyloseq object
phylogeny_bars_ggplot | create a ggplot barplot object of the compositons of each sample at a taxonomic level
taxa_abundance_bars_ggplot | create a ggplot object of the abundance of taxa in each sample
tsne_phyloseq_ggplot  | create a ggplot object of the t-SNE from a phyloseq object

## Calculations
Call			 | Use
---------------- | ------------------------------------------------
co_occurrence | calculate co-occurrence between taxa
curate_cooccurrence | subsets the co-occurence table to specific taxa
bootstrap_rho | runs permutations of the otu_table to calculate a significant $\rho$ value

## Datasets
Originally I had created 2 mock phyloseq objects (`mock_phyloseq` and `mock_phyloseq2`) that had no real-world data but served to show simple examples of how the functions worked. 

Then I decided that I should include a real example of microbiome data (`soil_column`) becasue it's always nice to see real examples. `soil_column` is a <a href="https://www.frontiersin.org/articles/10.3389/fmicb.2018.03197/full" target="_blank" >published dataset</a>  from my lab-group. The data is from an experiment where they looked at the microbial composition of farmland soil before and after manure application, over time, using 16S-sequencing.

But then I figured everyone looks at microbes and science-related data all day, and maybe some people might want something a little more fun than that or `iris`-es.. so I put together `mtg_legacy`. `mtg_legacy` is a compilation of decks from the Legacy format of the Trading Card game Magic the Gathering. In this dataset I have pooled the top 8 decklists from major tournaments around the world from July, 2018, to March, 2019 (the era post Deathrite Shaman banning.. R.I.P.).

# Function Documentation
### taxa_filter()
This is a robust function that is implemented in nearly every other function of this package. It uses many of the subsetting processes distributed within `phyloseq`, but strives to make them a more user-friendly and combined into a one-stop function. The function works in several steps.

  * Checks to see if `treatments` were specified. If so, it splits the phyloseq into separate objects for each treatment to process.
  * Check to see which taxa are seen in a proportion of samples across each phyloseq object > `frequency` (filtering out taxa seen in few samples) and then merge back to one object
  * If `subset` is declared, remove all `treatment` outside of the `subset`
  * If `drop_samples` is `TRUE` then remove any samples that have 0 taxa observed after filtering (this is a very situational need)

If `frequency` is set to 0 (default), then the function removes any taxa with no abundance in any sample.
***Useful for:***
  * subsetting by sample_data factors
  * removing low-presence taxa
  * removing high-presence taxa
***Usage***
```r
taxa_filter(phyloseq_obj, treatment = NULL, subset = NULL, frequency = 0, below = FALSE, drop_samples = FALSE)
```
***Arguments***

Call | Description
---------------- | ------------------------------------------------
`phyloseq_obj` | A phyloseq-class object. It must contain sample_data() with information about each sample, and it must contain tax_table() with information about each taxa/gene.
`treatment` | Column name as a string or number in the \code{\link[phyloseq:sample_data]{sample_data}}. This can be a vector of multiple columns and they will be combined into a new column.
`subset` | A factor within the \code{treatment}. This will remove any samples that to not contain this factor. This can be a vector of multiple factors to subset on.
`frequency` | The proportion of samples the taxa is found in.
`below` | Does frequency define the minimum (\code{FALSE}) or maximum (\code{TRUE}) proportion of samples the taxa is found in.
`drop_samples` | Should the function remove samples that that are empty after removing taxa filtered by frequency (\code{TRUE}).
***Examples***
The `soil_column` data has 18,441 OTUs listed in its `taxa_table`.
```{r check_data}
soil_column
```
However, 339 of those taxa are not actually seen in any of the samples.
```{r number_emtpy_taxa}
length(phyloseq::taxa_sums(soil_column)[phyloseq::taxa_sums(soil_column) == 0])
```
`taxa_filter` with `frequency = 0` will remove those taxa.
```{r taxa_filter_1}
taxa_filter(soil_column, frequency = 0)
```
Say that we wanted to only look at taxa that are seen in 80% of the samples.
```{r taxa_filter_2}
taxa_filter(soil_column, frequency = 0.80)
```
But if we want taxa that are seen in 80% of any 1 teatment group;
```{r taxa_filter_3}
taxa_filter(soil_column, frequency = 0.80, treatment = 'Treatment')
```
It returns a larger number of taxa, since they need to be seen in less samples overall.

In `soil_column`, the actual experimental conditions are a combination of the `Matrix` and `Treatment` columns, and the function can handle that too.
```{r taxa_filter_4}
taxa_filter(soil_column, frequency = 0.80, treatment = c('Matrix', 'Treatment'))
```

### merge_treatments()
Combines multiple columns from the sample-data into a single column. Doing this can make it easier to subset and look at the data on multiple factors. If you looked at the last example from `taxa_filter` you may have noticed there was an additional sample variable after the function ran. That is becasue when multiple `treatment` are given, it uses this function to combine them for subsetting.
***Usage***
```r
merge_treatments(phyloseq_obj, ...)
```
***Arguments***

Call | Ddescription
---------------- | ------------------------------------------------
`phyloseq_obj` | A phyloseq-class object. It must contain sample_data() with information about each sample.
`...` | any number of column names as strings or numbers in the \code{\link[phyloseq:sample_data]{sample_data}} that are to be combined.

***Examples***
```{r merge_treatments}
merge_treatments(soil_column, 'Matrix', 2, 'Day')@sam_data[1:4,]
```

### merge_samples()
This function merges samples that match on the given criteria (`merge_on`). Any sample_data factors that do not match will be set to `NA`. otu_table counts will be reassigned as the mean of all the samples that are merged together. Use this with caution as replicate samples may be crucial to the experimental design and should be proven statistically to be similar enough to combine for downstream analysis. 
***Usage***
```r
merge_samples(phyloseq_obj, treatment, subset = NULL, merge_on = treatment)
```
***Arguments***

Call | Description
---------------- | ------------------------------------------------
`phyloseq_obj` |  A \code{\link[phyloseq]{phyloseq-class}} object. It must contain \code{\link[phyloseq:sample_data]{sample_data()}}) with information about each sample, and it must contain \code{\link[phyloseq:tax_table]{tax_table()}}) with information about each taxa/gene.
`treatment` | Column name as a string or number in the \code{\link[phyloseq:sample_data]{sample_data}}. This can be a vector of multiple columns and they will be combined into a new column.
`subset` | A factor within the \code{treatment}. This will remove any samples that to not contain this factor. This can be a vector of multiple factors to subset on.
`merge_on` | Defines which variable the data is merged according to. This needs to be a column name as a string or number in the \code{\link[phyloseq:sample_data]{sample_data}}. This can be a vector of multiple columns and they will be combined into a new column.

***Examples***
```{r merge_samples}
# merge_samples(soil_column, treatment = 'Matrix', subset = 'Manure', merge_on = 'Day')
```

### order_treatment()

***Arguments***

Call | Description
---------------- | ------------------------------------------------
`phyloseq_obj` | A \code{\link[phyloseq]{phyloseq-class}} object. It must contain \code{\link[phyloseq:sample_data]{sample_data()}}) with information about each sample, and it must contain \code{\link[phyloseq:tax_table]{tax_table()}}) with information about each taxa/gene.
`treatment` | Column name as a string or number in the \code{\link[phyloseq:sample_data]{sample_data}}.
`order` | The order of factors in \code{treatment} column as a vector of strings.

This is a simple function to convert the the `otu_table` count data to relative abundance. Relative abundance sets the count sums for each sample to 1, and then assigns each taxa an abundance equal to its proportion on the total sum.

***Examples***

```{r order_treatment}
levels(soil_column@sam_data$Day)
ordered_days <- order_treatment(soil_column, 'Day', c(0, 10, 24, 38, 59, 80, 108))
levels(ordered_days@sam_data$Day)
```

### relative_abundance()

***Arguments***

Call | Description
---------------- | ------------------------------------------------
`phyloseq_obj` | A phyloseq-class object that contains `otu_table` count data.

This is a simple function to convert the the `otu_table` count data to relative abundance. Relative abundance sets the count sums for each sample to 1, and then assigns each taxa an abundance equal to its proportion on the total sum.

***Examples***

```{r relative_abundance}
phyloseq::sample_sums( relative_abundance(soil_column) )[1:5]
```

### co_occurrence()

This function is an implementation of the pair-wise Spearman rank correlation that you can call in `R`. The results should be identical. <a href="https://github.com/germs-lab/FastCoOccur" target="_blank" >FastCoOccur</a> was originally written by <a href="https://github.com/metajinomics" target="_blank" >Jin Choi</a> in C++ to be called from the command-line. I rewrote the routine, implementing the <a href="http://www.rcpp.org/" target="_blank" >Rcpp</a> API, so that it could be called within R, and with a phyloseq-object as the input. 

```r
data(mock_phyloseq)
FastCoOccur(mock_phyloseq, "day", 0.05)
```
